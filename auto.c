#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C2_1,     motorRightF,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorRightR,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorLeftF,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorLeftR,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     flagMotor,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    trayTiltMotor,        tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    upperLiftMotor,       tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

// Autonomous 12-7-13

void initializeRobot()
{
	// set tray to tilt
	servo[trayTiltMotor] = 189;

	// push parts down untill press NXT button
	motor[liftMotor] = 20;
	servo[upperLiftMotor] = 130;
	//while (nNxtButtonPressed == -1) {}
	motor[liftMotor] = 0;
	servo[upperLiftMotor] = 122;

	// reset the lift motor encoder
	nMotorEncoder[liftMotor] = 0;
	return;
}

float leftWheelType, rightWheelType;

void holomic(float x, float y)
{
	float xIn = x * 100;
	float yIn = y * 100;
	// Negate y for the joystick.
	//yIn = -yIn;


	leftWheelType = xIn + yIn;
	rightWheelType = -xIn + yIn;

	//leftWheelType = normalizeFloats(leftWheelType);
	//rightWheelType = normalizeFloats(rightWheelType);

	motor[motorLeftF] = leftWheelType;
	motor[motorRightF] = rightWheelType;
	motor[motorLeftR] = rightWheelType;
	motor[motorRightR] = leftWheelType;
}

int leftmotorval, rightmotorval, quadrent = 0;

float whichismax(float left, float right) {
	float returnval;
	if (left > right) returnval = left;
	if (right > left) returnval = right;
	if (right == left) returnval = (left + right) / 2;
	return returnval;
}

void nonholomic(int leftstickval, int rightstickval) {

	if (leftstickval > 0.0) {
		if (rightstickval > 0.0) {
			quadrent = 1;
			leftmotorval = leftstickval - rightstickval;
			rightmotorval = whichismax(leftstickval, rightstickval);
			} else {
			quadrent = 2;
			leftmotorval = whichismax(leftstickval, (rightstickval * -1.0));
			rightmotorval = leftstickval + rightstickval;
		}
		} else {
		if (rightstickval > 0.0) {
			quadrent = 3;
			leftmotorval = (whichismax((leftstickval * -1.0), rightstickval)) * -1.0;
			rightmotorval = leftstickval + rightstickval;
			} else {
			quadrent = 4;
			leftmotorval = leftstickval - rightstickval;
			rightmotorval = (whichismax((leftstickval * -1.0), (rightstickval * -1.0))) * -1.0;
		}
	}

	motor[motorLeftF] = leftmotorval;
	motor[motorLeftR] = leftmotorval;
	motor[motorRightF] = rightmotorval;
	motor[motorRightR] = rightmotorval;
}

void moveForward(int inches) {
		holomic(0, 50);
		wait1Msec(inches * 32);
		holomic(0,0);
}

void moveBackward(int inches) {
		holomic(0, -50);
		wait1Msec(inches * 32);
		holomic(0, 0);
}

void moveSideways(int inches) {
		holomic((inches < 0 ? -100 : 100), 0);
		wait1Msec(inches * 75);
		holomic(0,0);
}


task main()
{
	initializeRobot();

	waitForStart();

	moveForward(24);
	wait1Msec(700);
	moveSideways(10);
	wait1Msec(200);
	moveBackward(24);

}
